{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to cleantest's documentation! cleantest is a testing framework for developers who need clean testing environments in a hurry. History The first version of cleantest was authored by Jason Nucciarone when he was having trouble finding a safe way to test destructive code locally on his system. He needed to test some code that he wrote to install and manage the Slurm Workload Manager, but he did not want to install the Debian packages directly on his system, and he did not want to go through the environment of setting up a CI/CD pipeline on GitHub. Irked by the idea of potentially needing to run his IDE out of a virtual machine and test his code there, he had an idea: what if there was library that could grab the body of a test, bring up a container, run the test inside that container, and then report back the results as if it never left the current process? With his idea in mind, he set out to scratch his itch, and eventually decided to name the collection of Python decorators he created cleantest . Over time, and after lots of feedback from colleagues and friends, cleantest is now the library you see before you. What is cleantest? The sales pitch for cleantest is a testing framework for developers who need clean testing environments in a hurry , but is more than just that. It aims to be an easy way to test code, whether you are on your laptop or an exa-scale high-performance computing cluster. It provides tools to work with popular packaging formats, utilities for pushing or pulling artifacts, and ways to test code across multiple Linux distributions. It also enables you to simulate high-performance computing clusters to test software deployments and installation scripts. If you are interested in learning more, then head on over to installation page of this documentation!","title":"Home"},{"location":"#welcome-to-cleantests-documentation","text":"cleantest is a testing framework for developers who need clean testing environments in a hurry.","title":"Welcome to cleantest's documentation!"},{"location":"#history","text":"The first version of cleantest was authored by Jason Nucciarone when he was having trouble finding a safe way to test destructive code locally on his system. He needed to test some code that he wrote to install and manage the Slurm Workload Manager, but he did not want to install the Debian packages directly on his system, and he did not want to go through the environment of setting up a CI/CD pipeline on GitHub. Irked by the idea of potentially needing to run his IDE out of a virtual machine and test his code there, he had an idea: what if there was library that could grab the body of a test, bring up a container, run the test inside that container, and then report back the results as if it never left the current process? With his idea in mind, he set out to scratch his itch, and eventually decided to name the collection of Python decorators he created cleantest . Over time, and after lots of feedback from colleagues and friends, cleantest is now the library you see before you.","title":"History"},{"location":"#what-is-cleantest","text":"The sales pitch for cleantest is a testing framework for developers who need clean testing environments in a hurry , but is more than just that. It aims to be an easy way to test code, whether you are on your laptop or an exa-scale high-performance computing cluster. It provides tools to work with popular packaging formats, utilities for pushing or pulling artifacts, and ways to test code across multiple Linux distributions. It also enables you to simulate high-performance computing clusters to test software deployments and installation scripts. If you are interested in learning more, then head on over to installation page of this documentation!","title":"What is cleantest?"},{"location":"about/license/","text":"Apache License Version 2.0, January 2004 < http://www.apache.org/licenses/ > Terms and Conditions for use, reproduction, and distribution 1. Definitions \u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License. \u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d \u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS","title":"License"},{"location":"about/license/#apache-license","text":"Version 2.0, January 2004 < http://www.apache.org/licenses/ >","title":"Apache License"},{"location":"about/license/#terms-and-conditions-for-use-reproduction-and-distribution","text":"","title":"Terms and Conditions for use, reproduction, and distribution"},{"location":"about/license/#1-definitions","text":"\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License. \u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d \u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.","title":"1. Definitions"},{"location":"about/license/#2-grant-of-copyright-license","text":"Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.","title":"2. Grant of Copyright License"},{"location":"about/license/#3-grant-of-patent-license","text":"Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.","title":"3. Grant of Patent License"},{"location":"about/license/#4-redistribution","text":"You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.","title":"4. Redistribution"},{"location":"about/license/#5-submission-of-contributions","text":"Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.","title":"5. Submission of Contributions"},{"location":"about/license/#6-trademarks","text":"This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.","title":"6. Trademarks"},{"location":"about/license/#7-disclaimer-of-warranty","text":"Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.","title":"7. Disclaimer of Warranty"},{"location":"about/license/#8-limitation-of-liability","text":"In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.","title":"8. Limitation of Liability"},{"location":"about/license/#9-accepting-warranty-or-additional-liability","text":"While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS","title":"9. Accepting Warranty or Additional Liability"},{"location":"examples/coming-soon/","text":"Coming soon This page is currently under construction Hey there from NucciTheBoss! I am in the process of creating some examples to demonstrate some of the cool things that you can do with cleantest such as creating a continuous integration pipeline on GitHub to test packages or building your own micro-HPC cluster to test that your simulation works. Stay tuned! Examples will be added in cleantest 0.5.0","title":"Examples"},{"location":"examples/coming-soon/#coming-soon","text":"This page is currently under construction Hey there from NucciTheBoss! I am in the process of creating some examples to demonstrate some of the cool things that you can do with cleantest such as creating a continuous integration pipeline on GitHub to test packages or building your own micro-HPC cluster to test that your simulation works. Stay tuned! Examples will be added in cleantest 0.5.0","title":"Coming soon"},{"location":"user-guide/getting-started/","text":"Getting started with cleantest Now that you have the cleantest framework installed on your system, let's get you introduced to writing some basic tests. This example assumes that you have LXD installed and configured, and cleantest is installed correctly on your system. If not, please revisit the installation documentation. Also, you will need to have pytest installed on your system as well. You can install it using the following command: pip install pytest Some background The goal of the cleantest framework is to provide an easy way to bring up clean testing environments without a hassle. A \"clean test\" is a test written with cleantest that can drop on top of a pre-existing testing framework such as pytest or unittest. These \"clean tests\" can be broken down into three parts: Configuration statements A collection of Testlets One or more Test Suites Configuration statements control the state and flow of cleantest, testlets are the tests to be run in the testing environment, and the test suites define the order in which the testlets are executed. Defining a testlet A testlet is essentially an entire Python script encapsulated in a function; it contains all the imports, definitions, and logic a program needs to run. Here is an example of a testlet below: from cleantest.provider import lxd @lxd () def do_something (): import sys try : import urllib sys . exit ( 0 ) except ImportError : sys . exit ( 1 ) An important thing to note about testlets is that they are not run in the same Python interpreter as the test suite. The testlets are actually picked up by the interpreter and run somewhere else, and a Result object is returned containing an exit code, stdout, and stderr. Therefore, you should always import the Python modules and assets you need within the body of the testlet, not in the main test files. Writing a test suite To evaluate the results of a testlet, you need a test suite . This part should be invoked by your testing framework of choice. In our case, we used pytest : class TestSuite : def test_do_something ( self ) -> None : results = do_something () for name , result in results . items () assert result . exit_code == 0 The test suite should be focused solely on launching testlets and evaluating the results. You should never define testlets inside a test suite. They should always be a top-level, globally accessible function. Bringing it all together To bring it all together, combine the testlet and test suite combined into a single Python file: #!/usr/bin/env python3 \"\"\"A basic test.\"\"\" from cleantest.provider import lxd @lxd ( preserve = False ) def do_something (): import sys try : import urllib sys . exit ( 0 ) except ImportError : sys . exit ( 1 ) class TestSuite : def test_do_something ( self ) -> None : results = do_something () for name , result in results . items () assert result . exit_code == 0 Now use pytest to run the test: pytest my_cleantest.py You should see the following output from your test: =========== test session starts =========== platform linux -- Python 3.10.4, pytest-7.1.3, pluggy-1.0.0 rootdir: /mnt/d/scratch collected 1 item basic_test.py . [100%] =========== 1 passed in 8.95s =========== Congrats, you have written your first clean test! Next steps Now that you have taken your first introductory steps with cleantest, you should now go through the rest of the documentation and examples to learn about all the things that you can do with cleantest! Of course, learning through trial and error also works.","title":"Getting started"},{"location":"user-guide/getting-started/#getting-started-with-cleantest","text":"Now that you have the cleantest framework installed on your system, let's get you introduced to writing some basic tests. This example assumes that you have LXD installed and configured, and cleantest is installed correctly on your system. If not, please revisit the installation documentation. Also, you will need to have pytest installed on your system as well. You can install it using the following command: pip install pytest","title":"Getting started with cleantest"},{"location":"user-guide/getting-started/#some-background","text":"The goal of the cleantest framework is to provide an easy way to bring up clean testing environments without a hassle. A \"clean test\" is a test written with cleantest that can drop on top of a pre-existing testing framework such as pytest or unittest. These \"clean tests\" can be broken down into three parts: Configuration statements A collection of Testlets One or more Test Suites Configuration statements control the state and flow of cleantest, testlets are the tests to be run in the testing environment, and the test suites define the order in which the testlets are executed.","title":"Some background"},{"location":"user-guide/getting-started/#defining-a-testlet","text":"A testlet is essentially an entire Python script encapsulated in a function; it contains all the imports, definitions, and logic a program needs to run. Here is an example of a testlet below: from cleantest.provider import lxd @lxd () def do_something (): import sys try : import urllib sys . exit ( 0 ) except ImportError : sys . exit ( 1 ) An important thing to note about testlets is that they are not run in the same Python interpreter as the test suite. The testlets are actually picked up by the interpreter and run somewhere else, and a Result object is returned containing an exit code, stdout, and stderr. Therefore, you should always import the Python modules and assets you need within the body of the testlet, not in the main test files.","title":"Defining a testlet"},{"location":"user-guide/getting-started/#writing-a-test-suite","text":"To evaluate the results of a testlet, you need a test suite . This part should be invoked by your testing framework of choice. In our case, we used pytest : class TestSuite : def test_do_something ( self ) -> None : results = do_something () for name , result in results . items () assert result . exit_code == 0 The test suite should be focused solely on launching testlets and evaluating the results. You should never define testlets inside a test suite. They should always be a top-level, globally accessible function.","title":"Writing a test suite"},{"location":"user-guide/getting-started/#bringing-it-all-together","text":"To bring it all together, combine the testlet and test suite combined into a single Python file: #!/usr/bin/env python3 \"\"\"A basic test.\"\"\" from cleantest.provider import lxd @lxd ( preserve = False ) def do_something (): import sys try : import urllib sys . exit ( 0 ) except ImportError : sys . exit ( 1 ) class TestSuite : def test_do_something ( self ) -> None : results = do_something () for name , result in results . items () assert result . exit_code == 0 Now use pytest to run the test: pytest my_cleantest.py You should see the following output from your test: =========== test session starts =========== platform linux -- Python 3.10.4, pytest-7.1.3, pluggy-1.0.0 rootdir: /mnt/d/scratch collected 1 item basic_test.py . [100%] =========== 1 passed in 8.95s =========== Congrats, you have written your first clean test!","title":"Bringing it all together"},{"location":"user-guide/getting-started/#next-steps","text":"Now that you have taken your first introductory steps with cleantest, you should now go through the rest of the documentation and examples to learn about all the things that you can do with cleantest! Of course, learning through trial and error also works.","title":"Next steps"},{"location":"user-guide/hooks/","text":"Using hooks Hooks are used to run actions at various stages of the cleantest lifecycle. They can be used to configure test environments after they have been created, upload dependencies into the test environment, or download artifacts after the test has finished. Currently, there are two supported hook types. Their usage is described below. StartEnvHook StartEnvHook , or start environment hook , is a hook that is run after a test environment instance has been created and initialized. It has two main usages: Install dependencies needed by the testlet. Uploading artifacts needed by the testlet to run. Start environment hooks accept the following arguments: name (str) : Name of the hook. Must be unique. packages (List[Injectable]) : List of packages to install inside the test environment instance before running the testlet. upload (List[Injectable]) : List of artifacts to upload from the local system to the test environment instance. Example usage #!/usr/bin/env python3 \"\"\"Example usage of StartEnvHook.\"\"\" import os from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Connection , Plug , Slot , Snap from cleantest.provider import lxd root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"test_snaps\" , packages = [ Snap ( snaps = \"pypi-server\" , connections = [ Connection ( Plug ( \"pypi-server\" , \"removable-media\" ), Slot ( name = \"removable-media\" )) ], ), Snap ( local_snaps = os . path . join ( root , \"hello-world-gtk_0.1_amd64.snap\" ), dangerous = True ), ], ) config . register_hook ( start_hook ) @lxd ( image = \"jammy-amd64\" , preserve = False ) def functional_snaps (): import sys from shutil import which if which ( \"pypi-server\" ) is None : sys . exit ( 1 ) elif which ( \"hello-world-gtk\" ) is None : sys . exit ( 1 ) else : sys . exit ( 0 ) class TestLocalLXD : def test_snap_package ( self ) -> None : results = functional_snaps () for name , result in results . items (): assert result . exit_code == 0 StopEnvHook StopEnvHook , or stop environment hook , is a hook that is run after the testlet has completed inside the test environment instance. It has one main usage: Downloading artifacts after the testlet has completed. Stop environment hooks accept the following arguments: name (str) : Name of the hook. Must be unique. download (List[Injectable]) : List of artifacts to download from the test environment instance to the local system. Example usage #!/usr/bin/env python3 \"\"\"Example usage of StopEnvHook.\"\"\" import os import pathlib import tempfile from cleantest import Configure from cleantest.hooks import StopEnvHook from cleantest.hooks.data import Dir , File from cleantest.provider import lxd config = Configure () stop_hook = StopEnvHook ( name = \"download_artifact\" , download = [ File ( \"/root/dump.txt\" , os . path . join ( tempfile . gettempdir (), \"dump.txt\" ), overwrite = True ), Dir ( \"/root/dump\" , os . path . join ( tempfile . gettempdir (), \"dump\" ), overwrite = True ), ], ) config . register_hook ( stop_hook ) @lxd ( image = \"jammy-amd64\" , preserve = True ) def work_on_artifacts (): import os import pathlib pathlib . Path ( \"/root/dump.txt\" ) . write_text ( \"Dumped like a sack of rocks\" ) os . mkdir ( \"/root/dump\" ) pathlib . Path ( \"/root/dump/dump_1.txt\" ) . write_text ( \"Oh I have been dumped again!\" ) class TestUploadDownload : def test_upload_download ( self ) -> None : work_on_artifacts () assert pathlib . Path ( tempfile . gettempdir ()) . joinpath ( \"dump.txt\" ) . is_file () is True assert pathlib . Path ( tempfile . gettempdir ()) . joinpath ( \"dump\" ) . is_dir () is True","title":"Using hooks"},{"location":"user-guide/hooks/#using-hooks","text":"Hooks are used to run actions at various stages of the cleantest lifecycle. They can be used to configure test environments after they have been created, upload dependencies into the test environment, or download artifacts after the test has finished. Currently, there are two supported hook types. Their usage is described below.","title":"Using hooks"},{"location":"user-guide/hooks/#startenvhook","text":"StartEnvHook , or start environment hook , is a hook that is run after a test environment instance has been created and initialized. It has two main usages: Install dependencies needed by the testlet. Uploading artifacts needed by the testlet to run. Start environment hooks accept the following arguments: name (str) : Name of the hook. Must be unique. packages (List[Injectable]) : List of packages to install inside the test environment instance before running the testlet. upload (List[Injectable]) : List of artifacts to upload from the local system to the test environment instance.","title":"StartEnvHook"},{"location":"user-guide/hooks/#example-usage","text":"#!/usr/bin/env python3 \"\"\"Example usage of StartEnvHook.\"\"\" import os from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Connection , Plug , Slot , Snap from cleantest.provider import lxd root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"test_snaps\" , packages = [ Snap ( snaps = \"pypi-server\" , connections = [ Connection ( Plug ( \"pypi-server\" , \"removable-media\" ), Slot ( name = \"removable-media\" )) ], ), Snap ( local_snaps = os . path . join ( root , \"hello-world-gtk_0.1_amd64.snap\" ), dangerous = True ), ], ) config . register_hook ( start_hook ) @lxd ( image = \"jammy-amd64\" , preserve = False ) def functional_snaps (): import sys from shutil import which if which ( \"pypi-server\" ) is None : sys . exit ( 1 ) elif which ( \"hello-world-gtk\" ) is None : sys . exit ( 1 ) else : sys . exit ( 0 ) class TestLocalLXD : def test_snap_package ( self ) -> None : results = functional_snaps () for name , result in results . items (): assert result . exit_code == 0","title":"Example usage"},{"location":"user-guide/hooks/#stopenvhook","text":"StopEnvHook , or stop environment hook , is a hook that is run after the testlet has completed inside the test environment instance. It has one main usage: Downloading artifacts after the testlet has completed. Stop environment hooks accept the following arguments: name (str) : Name of the hook. Must be unique. download (List[Injectable]) : List of artifacts to download from the test environment instance to the local system.","title":"StopEnvHook"},{"location":"user-guide/hooks/#example-usage_1","text":"#!/usr/bin/env python3 \"\"\"Example usage of StopEnvHook.\"\"\" import os import pathlib import tempfile from cleantest import Configure from cleantest.hooks import StopEnvHook from cleantest.hooks.data import Dir , File from cleantest.provider import lxd config = Configure () stop_hook = StopEnvHook ( name = \"download_artifact\" , download = [ File ( \"/root/dump.txt\" , os . path . join ( tempfile . gettempdir (), \"dump.txt\" ), overwrite = True ), Dir ( \"/root/dump\" , os . path . join ( tempfile . gettempdir (), \"dump\" ), overwrite = True ), ], ) config . register_hook ( stop_hook ) @lxd ( image = \"jammy-amd64\" , preserve = True ) def work_on_artifacts (): import os import pathlib pathlib . Path ( \"/root/dump.txt\" ) . write_text ( \"Dumped like a sack of rocks\" ) os . mkdir ( \"/root/dump\" ) pathlib . Path ( \"/root/dump/dump_1.txt\" ) . write_text ( \"Oh I have been dumped again!\" ) class TestUploadDownload : def test_upload_download ( self ) -> None : work_on_artifacts () assert pathlib . Path ( tempfile . gettempdir ()) . joinpath ( \"dump.txt\" ) . is_file () is True assert pathlib . Path ( tempfile . gettempdir ()) . joinpath ( \"dump\" ) . is_dir () is True","title":"Example usage"},{"location":"user-guide/installation/","text":"Installation Install cleantest The latest stable release of cleantest can be installed using pip : pip install cleantest You can also install the latest, bleeding-edge, and potentially unstable development branch from GitHub using the following commands: git clone https://github.com/NucciTheBoss/cleantest.git cd cleantest python3 -m pip install . Warning Before you can start writing tests using cleantest, you must also set up a test environment provider. Setting up testing environment providers You can use the following instructions to set up a supported test environment provider of your choice to be used with cleantest . Note that you do not need to install every testing environment provider listed below ; you only need to install the providers you wish to use for testing. About supported test environment providers LXD is currently the only supported test environment provider. For the best experience, I encourage you to use LXD on Ubuntu. You can connect to the LXD server from other machines such as Mac, Windows, and Linux* using the LXC client. How to set up the LXC client on Mac and Windows is beyond the scope of this documentation for now. I only currently have the means to use Ubuntu (and it is my favorite distro; sorry Arch/Fedora.) I have plans to add more test environment provides (ssh, libvirt/kvm, vagrant, etc.) in the future, but for now I am focused on LXD. LXD To use LXD as a test environment provider with cleantest , you will need to have the snap package manager and snapd service installed on your host system. Once you have snapd and the snap package manager on your host system, use the following command to install LXD: sudo snap install lxd After LXD has finished installing on the host system, use the following command to initialize a basic LXD cluster: lxd init --auto Once the LXD cluster finishes initializing, you can now use LXD as a test environment provider with cleantest .","title":"Installation"},{"location":"user-guide/installation/#installation","text":"","title":"Installation"},{"location":"user-guide/installation/#install-cleantest","text":"The latest stable release of cleantest can be installed using pip : pip install cleantest You can also install the latest, bleeding-edge, and potentially unstable development branch from GitHub using the following commands: git clone https://github.com/NucciTheBoss/cleantest.git cd cleantest python3 -m pip install . Warning Before you can start writing tests using cleantest, you must also set up a test environment provider.","title":"Install cleantest"},{"location":"user-guide/installation/#setting-up-testing-environment-providers","text":"You can use the following instructions to set up a supported test environment provider of your choice to be used with cleantest . Note that you do not need to install every testing environment provider listed below ; you only need to install the providers you wish to use for testing. About supported test environment providers LXD is currently the only supported test environment provider. For the best experience, I encourage you to use LXD on Ubuntu. You can connect to the LXD server from other machines such as Mac, Windows, and Linux* using the LXC client. How to set up the LXC client on Mac and Windows is beyond the scope of this documentation for now. I only currently have the means to use Ubuntu (and it is my favorite distro; sorry Arch/Fedora.) I have plans to add more test environment provides (ssh, libvirt/kvm, vagrant, etc.) in the future, but for now I am focused on LXD.","title":"Setting up testing environment providers"},{"location":"user-guide/installation/#lxd","text":"To use LXD as a test environment provider with cleantest , you will need to have the snap package manager and snapd service installed on your host system. Once you have snapd and the snap package manager on your host system, use the following command to install LXD: sudo snap install lxd After LXD has finished installing on the host system, use the following command to initialize a basic LXD cluster: lxd init --auto Once the LXD cluster finishes initializing, you can now use LXD as a test environment provider with cleantest .","title":"LXD"},{"location":"user-guide/parallelization/","text":"Running tests in parallel cleantest has the ability to run test environment instances in parallel to increase the efficiency of test runs. You can define the number of threads to use when running test environment instances in parallel as either arguments to the test environment provider, or you can pass the number of threads to use when the test run is started using the CLEANTEST_NUM_THREADS environment variable: CLEANTEST_NUM_THREADS = $( nproc ) pytest cleantest_test_suite.py This is the flow that cleantest follows when parallel testing is enabled for a testlet. Rather than proceeding through each image sequentially to bring up a test environment instance and inject the testlet, each instance is brought up independently in a separate thread and the testlet is injected there. cleantest blocks until all threads have completed. stateDiagram-v2 start : @testenvprovider(name=\"test\", image=[\"jammy-amd64\", \"focal-amd64\", \"bionic-amd64\"]) instances : [\"test-jammy-amd64\", \"test-focal-amd64\", \"test-bionic-amd64\"] jammy : test-jammy-amd64 focal : test-focal-amd64 bionic : test-bionic-amd64 [*] --> start: Test run is started start --> instances: cleantest identifies instances to be created instances --> jammy: Thread #1 instances --> focal: Thread #2 instances --> bionic: Thread #3 jammy --> Results: Result of testlet focal --> Results: Result of testlet bionic --> Results: Result of testlet Results --> Evaluation: Result from each instance is evaluated on local system Evaluation --> [*] cleantest's built-in parallel testing support is best suited for spread testing; you have a testlet that you need to test across different types of test environment instances. For testing multiple testlets in parallel, you need to use one of Python's many parallel computing libraries, or third-party tool such as xargs or GNU parallel. Examples LXD #!/usr/bin/env python3 \"\"\"Parallel testing example using LXD as test environment provider.\"\"\" import os from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Pip from cleantest.provider import lxd config = Configure () start_hook = StartEnvHook ( name = \"pip_injection\" , packages = [ Pip ( packages = \"tabulate\" )]) config . register_hook ( start_hook ) @lxd ( image = [ \"jammy-amd64\" , \"focal-amd64\" , \"bionic-amd64\" ], preserve = False , parallel = True , num_threads = os . cpu_count (), ) def install_tabulate (): import sys try : from tabulate import tabulate print ( \"tabulate is installed.\" , file = sys . stdout ) except ImportError : print ( \"Failed to import tabulate package.\" , file = sys . stderr ) sys . exit ( 1 ) sys . exit ( 0 ) class TestParallelLXD : def test_parallel_lxd ( self ) -> None : results = install_tabulate () for name , result in results . items (): try : assert result . exit_code == 0 except AssertionError : raise Exception ( f \" { name } failed. Result: { result } \" )","title":"Parallel testing"},{"location":"user-guide/parallelization/#running-tests-in-parallel","text":"cleantest has the ability to run test environment instances in parallel to increase the efficiency of test runs. You can define the number of threads to use when running test environment instances in parallel as either arguments to the test environment provider, or you can pass the number of threads to use when the test run is started using the CLEANTEST_NUM_THREADS environment variable: CLEANTEST_NUM_THREADS = $( nproc ) pytest cleantest_test_suite.py This is the flow that cleantest follows when parallel testing is enabled for a testlet. Rather than proceeding through each image sequentially to bring up a test environment instance and inject the testlet, each instance is brought up independently in a separate thread and the testlet is injected there. cleantest blocks until all threads have completed. stateDiagram-v2 start : @testenvprovider(name=\"test\", image=[\"jammy-amd64\", \"focal-amd64\", \"bionic-amd64\"]) instances : [\"test-jammy-amd64\", \"test-focal-amd64\", \"test-bionic-amd64\"] jammy : test-jammy-amd64 focal : test-focal-amd64 bionic : test-bionic-amd64 [*] --> start: Test run is started start --> instances: cleantest identifies instances to be created instances --> jammy: Thread #1 instances --> focal: Thread #2 instances --> bionic: Thread #3 jammy --> Results: Result of testlet focal --> Results: Result of testlet bionic --> Results: Result of testlet Results --> Evaluation: Result from each instance is evaluated on local system Evaluation --> [*] cleantest's built-in parallel testing support is best suited for spread testing; you have a testlet that you need to test across different types of test environment instances. For testing multiple testlets in parallel, you need to use one of Python's many parallel computing libraries, or third-party tool such as xargs or GNU parallel.","title":"Running tests in parallel"},{"location":"user-guide/parallelization/#examples","text":"","title":"Examples"},{"location":"user-guide/parallelization/#lxd","text":"#!/usr/bin/env python3 \"\"\"Parallel testing example using LXD as test environment provider.\"\"\" import os from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Pip from cleantest.provider import lxd config = Configure () start_hook = StartEnvHook ( name = \"pip_injection\" , packages = [ Pip ( packages = \"tabulate\" )]) config . register_hook ( start_hook ) @lxd ( image = [ \"jammy-amd64\" , \"focal-amd64\" , \"bionic-amd64\" ], preserve = False , parallel = True , num_threads = os . cpu_count (), ) def install_tabulate (): import sys try : from tabulate import tabulate print ( \"tabulate is installed.\" , file = sys . stdout ) except ImportError : print ( \"Failed to import tabulate package.\" , file = sys . stderr ) sys . exit ( 1 ) sys . exit ( 0 ) class TestParallelLXD : def test_parallel_lxd ( self ) -> None : results = install_tabulate () for name , result in results . items (): try : assert result . exit_code == 0 except AssertionError : raise Exception ( f \" { name } failed. Result: { result } \" )","title":"LXD"},{"location":"user-guide/test-env-providers/","text":"Test environment providers Test environment providers are the backbone of cleantest; they provide the containers or virtual machines that cleantest injects the testlets into. Test environment providers can be thought of as hypervisors that can be controlled from Python. To control test environment providers, cleantest uses Python decorators. These decorators accept arguments from the user and capture the body of the testlet. The following is a list of all the supported test environment providers in cleantest and how to control them. LXD The lxd decorator handles running testlets inside of containers and/or virtual machines controlled by the LXD hypervisor. The decorator accepts the following arguments: name (str) : Prefix to use in name of test environment instances. Defaults to \"test\" . image (List[str]) : List of LXD images to use for created test environments. Defaults to [\"jammy-amd64\"] . preserve (bool) : Preserve test environment after testlet has completed. Defaults to True . env (EnvDataStore) : Environment to use in test environment. Defaults to base instance of EnvDataStore . data (LXDDataStore) : Data necessary for LXD hypervisor. Defaults to base instance of LXDDataStore . image_config (List[Dict[str, Any]]) : List of image configurations to add to LXDDataStore . client_config (LXDClientConfig) : Configuration to use for LXD client. Defaults to None . parallel (bool) : Run test environments in parallel. Defaults to False . num_threads (int) : Number of threads to use when running test environment in parallel. Defaults to None . Example usage #!/usr/bin/env python3 \"\"\"Example usage of LXD test environment provider.\"\"\" import os from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Charmlib , Pip from cleantest.provider import lxd # Define the hooks and register them. root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"my_start_hook\" , packages = [ Charmlib ( auth_token_path = os . path . join ( root , \"charmhub.secret\" ), charmlibs = [ \"charms.operator_libs_linux.v0.apt\" ], ), Pip ( requirements = os . path . join ( root , \"requirements.txt\" )), ], ) config . register_hook ( start_hook ) # Define the testlets. @lxd ( image = \"jammy-amd64\" , preserve = False ) def install_snapd (): import sys import charms.operator_libs_linux.v0.apt as apt try : apt . update () apt . add_package ( \"snapd\" ) print ( \"snapd installed.\" , file = sys . stdout ) except apt . PackageNotFoundError : print ( \"Package could not be found in cache or system.\" , file = sys . stderr ) sys . exit ( 1 ) except apt . PackageError as e : print ( f \"Could not install package. Reason: { e } \" , file = sys . stderr ) sys . exit ( 1 ) try : snapd = apt . DebianPackage . from_installed_package ( \"snapd\" ) print ( f \"snapd version { snapd . fullversion } is installed.\" , file = sys . stdout ) except apt . PackageNotFoundError : print ( \"Snapd failed to install.\" , file = sys . stderr ) sys . exit ( 1 ) try : from tabulate import tabulate print ( \"tabulate is installed.\" , file = sys . stdout ) except ImportError : print ( \"Failed to import tabulate package.\" , file = sys . stderr ) sys . exit ( 1 ) sys . exit ( 0 ) class TestLocalLXD : def test_local_lxd ( self ) -> None : results = install_snapd () for name , result in results . items (): assert result . exit_code == 0","title":"Test environment providers"},{"location":"user-guide/test-env-providers/#test-environment-providers","text":"Test environment providers are the backbone of cleantest; they provide the containers or virtual machines that cleantest injects the testlets into. Test environment providers can be thought of as hypervisors that can be controlled from Python. To control test environment providers, cleantest uses Python decorators. These decorators accept arguments from the user and capture the body of the testlet. The following is a list of all the supported test environment providers in cleantest and how to control them.","title":"Test environment providers"},{"location":"user-guide/test-env-providers/#lxd","text":"The lxd decorator handles running testlets inside of containers and/or virtual machines controlled by the LXD hypervisor. The decorator accepts the following arguments: name (str) : Prefix to use in name of test environment instances. Defaults to \"test\" . image (List[str]) : List of LXD images to use for created test environments. Defaults to [\"jammy-amd64\"] . preserve (bool) : Preserve test environment after testlet has completed. Defaults to True . env (EnvDataStore) : Environment to use in test environment. Defaults to base instance of EnvDataStore . data (LXDDataStore) : Data necessary for LXD hypervisor. Defaults to base instance of LXDDataStore . image_config (List[Dict[str, Any]]) : List of image configurations to add to LXDDataStore . client_config (LXDClientConfig) : Configuration to use for LXD client. Defaults to None . parallel (bool) : Run test environments in parallel. Defaults to False . num_threads (int) : Number of threads to use when running test environment in parallel. Defaults to None .","title":"LXD"},{"location":"user-guide/test-env-providers/#example-usage","text":"#!/usr/bin/env python3 \"\"\"Example usage of LXD test environment provider.\"\"\" import os from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Charmlib , Pip from cleantest.provider import lxd # Define the hooks and register them. root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"my_start_hook\" , packages = [ Charmlib ( auth_token_path = os . path . join ( root , \"charmhub.secret\" ), charmlibs = [ \"charms.operator_libs_linux.v0.apt\" ], ), Pip ( requirements = os . path . join ( root , \"requirements.txt\" )), ], ) config . register_hook ( start_hook ) # Define the testlets. @lxd ( image = \"jammy-amd64\" , preserve = False ) def install_snapd (): import sys import charms.operator_libs_linux.v0.apt as apt try : apt . update () apt . add_package ( \"snapd\" ) print ( \"snapd installed.\" , file = sys . stdout ) except apt . PackageNotFoundError : print ( \"Package could not be found in cache or system.\" , file = sys . stderr ) sys . exit ( 1 ) except apt . PackageError as e : print ( f \"Could not install package. Reason: { e } \" , file = sys . stderr ) sys . exit ( 1 ) try : snapd = apt . DebianPackage . from_installed_package ( \"snapd\" ) print ( f \"snapd version { snapd . fullversion } is installed.\" , file = sys . stdout ) except apt . PackageNotFoundError : print ( \"Snapd failed to install.\" , file = sys . stderr ) sys . exit ( 1 ) try : from tabulate import tabulate print ( \"tabulate is installed.\" , file = sys . stdout ) except ImportError : print ( \"Failed to import tabulate package.\" , file = sys . stderr ) sys . exit ( 1 ) sys . exit ( 0 ) class TestLocalLXD : def test_local_lxd ( self ) -> None : results = install_snapd () for name , result in results . items (): assert result . exit_code == 0","title":"Example usage"},{"location":"user-guide/using-diff-linux-distro/","text":"Using different Linux distributions This page is currently under construction Hey there from NucciTheBoss! cleantest is not yet able to support multiple Linux distributions like Debian, CentOS Stream, Alma Linux, Fedora, etc. The only distro officially supported right now is Ubuntu, mostly because Ubuntu is my distro of choice, and well... I work at Canonical. You can to pull your own images with the LXD test environment provider, but I have not gotten around to making that example yet. Mostly what needs to be done to support multiple distros is to refactor the LXDDataStore class. Currently I have the defaults hardcoded in, but I would like to potentially make cleantest more intelligent. Rather than hardcode, I would like to enable querying of the images: endpoint and other endpoints. That information can then be loaded in at runtime so that users will always have an update-to-date image list. Please bear with me while I work to make cleantest even better! Multidistro support will be added in cleantest 0.4.0","title":"Using different Linux distributions"},{"location":"user-guide/using-diff-linux-distro/#using-different-linux-distributions","text":"This page is currently under construction Hey there from NucciTheBoss! cleantest is not yet able to support multiple Linux distributions like Debian, CentOS Stream, Alma Linux, Fedora, etc. The only distro officially supported right now is Ubuntu, mostly because Ubuntu is my distro of choice, and well... I work at Canonical. You can to pull your own images with the LXD test environment provider, but I have not gotten around to making that example yet. Mostly what needs to be done to support multiple distros is to refactor the LXDDataStore class. Currently I have the defaults hardcoded in, but I would like to potentially make cleantest more intelligent. Rather than hardcode, I would like to enable querying of the images: endpoint and other endpoints. That information can then be loaded in at runtime so that users will always have an update-to-date image list. Please bear with me while I work to make cleantest even better! Multidistro support will be added in cleantest 0.4.0","title":"Using different Linux distributions"},{"location":"user-guide/artifacts/directory/","text":"Working with directories Directories can be uploaded to and downloaded from test environment instances as artifacts. Dir class The Dir class represents a directory. Its constructor accepts three arguments: src (str) : File path to load directory from. dest (str) : File path for where to dump directory. overwrite (bool) : Overwrite the directory if it already exists at dest . Defaults to False . Dir versus File When the Dir class's load method is invoked, an exception will be raised if src is determined to be a file and not a directory. This exception is raised because cleantest handles directories differently than files when dumping out to dest . If you are working with files, not directories, you should use the File class instead. Supported hooks The Dir class's behavior changes depending on the hook it is used with. Here is a list of hooks that support Dir and how Dir behaves when accessed by them: StartEnvHook src is loaded from local system and dest is the location to dump the directory inside the test environment instance. StopEnvHook src is loaded from the test environment instance and dest is the location to dump the directory on the local system. Example usage #!/usr/bin/env python3 \"\"\"Example usage of Dir class.\"\"\" import os import pathlib import tempfile from cleantest import Configure from cleantest.hooks import StartEnvHook , StopEnvHook from cleantest.hooks.data import Dir from cleantest.provider import lxd root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"upload_artifact\" , upload = [ Dir ( os . path . join ( root , \"greetings\" ), \"/root/greetings\" ), ], ) stop_hook = StopEnvHook ( name = \"download_artifact\" , download = [ Dir ( \"/root/dump\" , os . path . join ( tempfile . gettempdir (), \"dump\" ), overwrite = True ), ], ) config . register_hook ( start_hook , stop_hook ) @lxd ( image = \"jammy-amd64\" , preserve = True ) def work_on_artifacts (): import os import pathlib import sys print ( pathlib . Path ( \"/root/dump\" ) . is_dir (), file = sys . stdout ) os . mkdir ( \"/root/dump\" ) pathlib . Path ( \"/root/dump/dump_1.txt\" ) . write_text ( \"Oh I have been dumped again!\" ) class TestUploadDownload : def test_upload_download ( self ) -> None : work_on_artifacts () assert pathlib . Path ( tempfile . gettempdir ()) . joinpath ( \"dump\" ) . is_dir () is True","title":"Directories"},{"location":"user-guide/artifacts/directory/#working-with-directories","text":"Directories can be uploaded to and downloaded from test environment instances as artifacts.","title":"Working with directories"},{"location":"user-guide/artifacts/directory/#dir-class","text":"The Dir class represents a directory. Its constructor accepts three arguments: src (str) : File path to load directory from. dest (str) : File path for where to dump directory. overwrite (bool) : Overwrite the directory if it already exists at dest . Defaults to False . Dir versus File When the Dir class's load method is invoked, an exception will be raised if src is determined to be a file and not a directory. This exception is raised because cleantest handles directories differently than files when dumping out to dest . If you are working with files, not directories, you should use the File class instead.","title":"Dir class"},{"location":"user-guide/artifacts/directory/#supported-hooks","text":"The Dir class's behavior changes depending on the hook it is used with. Here is a list of hooks that support Dir and how Dir behaves when accessed by them: StartEnvHook src is loaded from local system and dest is the location to dump the directory inside the test environment instance. StopEnvHook src is loaded from the test environment instance and dest is the location to dump the directory on the local system.","title":"Supported hooks"},{"location":"user-guide/artifacts/directory/#example-usage","text":"#!/usr/bin/env python3 \"\"\"Example usage of Dir class.\"\"\" import os import pathlib import tempfile from cleantest import Configure from cleantest.hooks import StartEnvHook , StopEnvHook from cleantest.hooks.data import Dir from cleantest.provider import lxd root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"upload_artifact\" , upload = [ Dir ( os . path . join ( root , \"greetings\" ), \"/root/greetings\" ), ], ) stop_hook = StopEnvHook ( name = \"download_artifact\" , download = [ Dir ( \"/root/dump\" , os . path . join ( tempfile . gettempdir (), \"dump\" ), overwrite = True ), ], ) config . register_hook ( start_hook , stop_hook ) @lxd ( image = \"jammy-amd64\" , preserve = True ) def work_on_artifacts (): import os import pathlib import sys print ( pathlib . Path ( \"/root/dump\" ) . is_dir (), file = sys . stdout ) os . mkdir ( \"/root/dump\" ) pathlib . Path ( \"/root/dump/dump_1.txt\" ) . write_text ( \"Oh I have been dumped again!\" ) class TestUploadDownload : def test_upload_download ( self ) -> None : work_on_artifacts () assert pathlib . Path ( tempfile . gettempdir ()) . joinpath ( \"dump\" ) . is_dir () is True","title":"Example usage"},{"location":"user-guide/artifacts/file/","text":"Working with files Files can be uploaded to and downloaded from test environment instances as artifacts. File class The File class represents a file. Its constructor accepts three arguments: src (str) : File path to load file from. dest (str) : File path for where to dump file. overwrite (bool) : Overwrite the file if it already exists at dest . Defaults to False . File versus Dir When the File class's load method is invoked, an exception will be raised if src is determined to be a directory and not a file. This exception is raised because cleantest handles files differently than directories when dumping out to dest . If you are working with directories, not files, you should use the Dir class instead. Supported hooks The File class's behavior changes depending on the hook it is used with. Here is a list of hooks that support File and how File behaves when accessed by them: StartEnvHook src is loaded from local system and dest is the location to dump the file inside the test environment instance. StopEnvHook src is loaded from the test environment instance and dest is the location to dump the file on the local system. Example usage #!/usr/bin/env python3 \"\"\"Example usage of File class.\"\"\" import os import pathlib import tempfile from cleantest import Configure from cleantest.hooks import StartEnvHook , StopEnvHook from cleantest.hooks.data import File from cleantest.provider import lxd root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"upload_artifact\" , upload = [ File ( os . path . join ( root , \"greeting.txt\" ), \"/root/greeting.txt\" ), ], ) stop_hook = StopEnvHook ( name = \"download_artifact\" , download = [ File ( \"/root/dump.txt\" , os . path . join ( tempfile . gettempdir (), \"dump.txt\" ), overwrite = True ), ], ) config . register_hook ( start_hook , stop_hook ) @lxd ( image = \"jammy-amd64\" , preserve = True ) def work_on_artifacts (): import pathlib import sys print ( pathlib . Path ( \"/root/greeting.txt\" ) . is_file (), file = sys . stdout ) pathlib . Path ( \"/root/dump.txt\" ) . write_text ( \"Dumped like a sack of rocks\" ) class TestUploadDownload : def test_upload_download ( self ) -> None : work_on_artifacts () assert pathlib . Path ( tempfile . gettempdir ()) . joinpath ( \"dump.txt\" ) . is_file () is True","title":"Files"},{"location":"user-guide/artifacts/file/#working-with-files","text":"Files can be uploaded to and downloaded from test environment instances as artifacts.","title":"Working with files"},{"location":"user-guide/artifacts/file/#file-class","text":"The File class represents a file. Its constructor accepts three arguments: src (str) : File path to load file from. dest (str) : File path for where to dump file. overwrite (bool) : Overwrite the file if it already exists at dest . Defaults to False . File versus Dir When the File class's load method is invoked, an exception will be raised if src is determined to be a directory and not a file. This exception is raised because cleantest handles files differently than directories when dumping out to dest . If you are working with directories, not files, you should use the Dir class instead.","title":"File class"},{"location":"user-guide/artifacts/file/#supported-hooks","text":"The File class's behavior changes depending on the hook it is used with. Here is a list of hooks that support File and how File behaves when accessed by them: StartEnvHook src is loaded from local system and dest is the location to dump the file inside the test environment instance. StopEnvHook src is loaded from the test environment instance and dest is the location to dump the file on the local system.","title":"Supported hooks"},{"location":"user-guide/artifacts/file/#example-usage","text":"#!/usr/bin/env python3 \"\"\"Example usage of File class.\"\"\" import os import pathlib import tempfile from cleantest import Configure from cleantest.hooks import StartEnvHook , StopEnvHook from cleantest.hooks.data import File from cleantest.provider import lxd root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"upload_artifact\" , upload = [ File ( os . path . join ( root , \"greeting.txt\" ), \"/root/greeting.txt\" ), ], ) stop_hook = StopEnvHook ( name = \"download_artifact\" , download = [ File ( \"/root/dump.txt\" , os . path . join ( tempfile . gettempdir (), \"dump.txt\" ), overwrite = True ), ], ) config . register_hook ( start_hook , stop_hook ) @lxd ( image = \"jammy-amd64\" , preserve = True ) def work_on_artifacts (): import pathlib import sys print ( pathlib . Path ( \"/root/greeting.txt\" ) . is_file (), file = sys . stdout ) pathlib . Path ( \"/root/dump.txt\" ) . write_text ( \"Dumped like a sack of rocks\" ) class TestUploadDownload : def test_upload_download ( self ) -> None : work_on_artifacts () assert pathlib . Path ( tempfile . gettempdir ()) . joinpath ( \"dump.txt\" ) . is_file () is True","title":"Example usage"},{"location":"user-guide/packages/charmlib/","text":"Working with charm libraries Charm libraries are special Python modules used in charmed operators deployed by Juju . They are an easy way to distribute reusable code without needing to involve any particular package build system. Fundamentally, charm libraries are used to provide a means for charm developers to make the implementation of any relation they define as simple as possible for other charm developers. Note Comphrensive documentation on how to write/develop/use charm libraries are beyond the scope of this documentation. If you are interested in learning more about charm libraries, please refer to their official documentation here: https://juju.is/docs/sdk/libraries Charmlib class Charmlib is a package metaclass that represents the charm library installation command charmcraft fetch-lib . Its constructor accepts two arguments: auth_token_path (str) : File path to a Charmhub authentication token. This token is needed to download charm libraries from charmhub.io . charmlibs (List[str]) : List of charm libraries to install inside the test environment instance. Charm libraries are not installed a special directory such as site-packages or dist-packages; they are directly installed to a lib/ directory under your current working directory. Therefore, the Charmlib class modifies the PYTHONPATH environment variable to inform the Python interpreter that there are importable modules under lib/ . Example usage First, you need to create a Charmhub authentication token. This can be accomplished by using the following command in your shell: charmcraft login --export charmhub.secret After authenticating with Charmhub (you may need to create an Ubuntu One account), you can now use the example test script below: #!/usr/bin/env python3 \"\"\"Example usage of Charmlib package metaclass.\"\"\" import os from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Charmlib from cleantest.provider import lxd root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"charmlib_start_hook\" , packages = [ Charmlib ( auth_token_path = os . path . join ( root , \"charmhub.secret\" ), charmlibs = [ \"charms.operator_libs_linux.v0.apt\" ], ), ], ) config . register_hook ( start_hook ) @lxd ( image = \"jammy-amd64\" , preserve = False ) def install_snapd (): import sys import charms.operator_libs_linux.v0.apt as apt try : apt . update () apt . add_package ( \"snapd\" ) print ( \"snapd installed.\" , file = sys . stdout ) except apt . PackageNotFoundError : print ( \"Package could not be found in cache or system.\" , file = sys . stderr ) sys . exit ( 1 ) except apt . PackageError as e : print ( f \"Could not install package. Reason: { e } \" , file = sys . stderr ) sys . exit ( 1 ) try : snapd = apt . DebianPackage . from_installed_package ( \"snapd\" ) print ( f \"snapd version { snapd . fullversion } is installed.\" , file = sys . stdout ) except apt . PackageNotFoundError : print ( \"Snapd failed to install.\" , file = sys . stderr ) sys . exit ( 1 ) sys . exit ( 0 ) class TestCharmlib : def test_charmlib ( self ) -> None : results = install_snapd () for name , result in results . items (): assert result . exit_code == 0","title":"Charm libraries"},{"location":"user-guide/packages/charmlib/#working-with-charm-libraries","text":"Charm libraries are special Python modules used in charmed operators deployed by Juju . They are an easy way to distribute reusable code without needing to involve any particular package build system. Fundamentally, charm libraries are used to provide a means for charm developers to make the implementation of any relation they define as simple as possible for other charm developers. Note Comphrensive documentation on how to write/develop/use charm libraries are beyond the scope of this documentation. If you are interested in learning more about charm libraries, please refer to their official documentation here: https://juju.is/docs/sdk/libraries","title":"Working with charm libraries"},{"location":"user-guide/packages/charmlib/#charmlib-class","text":"Charmlib is a package metaclass that represents the charm library installation command charmcraft fetch-lib . Its constructor accepts two arguments: auth_token_path (str) : File path to a Charmhub authentication token. This token is needed to download charm libraries from charmhub.io . charmlibs (List[str]) : List of charm libraries to install inside the test environment instance. Charm libraries are not installed a special directory such as site-packages or dist-packages; they are directly installed to a lib/ directory under your current working directory. Therefore, the Charmlib class modifies the PYTHONPATH environment variable to inform the Python interpreter that there are importable modules under lib/ .","title":"Charmlib class"},{"location":"user-guide/packages/charmlib/#example-usage","text":"First, you need to create a Charmhub authentication token. This can be accomplished by using the following command in your shell: charmcraft login --export charmhub.secret After authenticating with Charmhub (you may need to create an Ubuntu One account), you can now use the example test script below: #!/usr/bin/env python3 \"\"\"Example usage of Charmlib package metaclass.\"\"\" import os from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Charmlib from cleantest.provider import lxd root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"charmlib_start_hook\" , packages = [ Charmlib ( auth_token_path = os . path . join ( root , \"charmhub.secret\" ), charmlibs = [ \"charms.operator_libs_linux.v0.apt\" ], ), ], ) config . register_hook ( start_hook ) @lxd ( image = \"jammy-amd64\" , preserve = False ) def install_snapd (): import sys import charms.operator_libs_linux.v0.apt as apt try : apt . update () apt . add_package ( \"snapd\" ) print ( \"snapd installed.\" , file = sys . stdout ) except apt . PackageNotFoundError : print ( \"Package could not be found in cache or system.\" , file = sys . stderr ) sys . exit ( 1 ) except apt . PackageError as e : print ( f \"Could not install package. Reason: { e } \" , file = sys . stderr ) sys . exit ( 1 ) try : snapd = apt . DebianPackage . from_installed_package ( \"snapd\" ) print ( f \"snapd version { snapd . fullversion } is installed.\" , file = sys . stdout ) except apt . PackageNotFoundError : print ( \"Snapd failed to install.\" , file = sys . stderr ) sys . exit ( 1 ) sys . exit ( 0 ) class TestCharmlib : def test_charmlib ( self ) -> None : results = install_snapd () for name , result in results . items (): assert result . exit_code == 0","title":"Example usage"},{"location":"user-guide/packages/pip/","text":"Working with pip packages Pip is the package installer for the Python programming language. You can use it to install packages from the Python Package Index (PYPI) . Pip class Pip is a package metaclass that represents the Python package installation command pip install . Its constructor accepts three arguments: packages (List[str]) : List of packages to install. Packages are pulled from PYPI. Defaults to None . requirements (List[str]) : List of paths to requirements.txt files. Defaults to None . constraints (List[str]) : List of paths to constraints.txt files. Defaults to None . Warning about using multiple requirements and constraints files The requirements and constraints fields in Pip are one-to-one . If you define multiple requirements files to use and want to use a constraints file with one of the requirements files, then you will need to define a constraints file for each of the requirements files in the list. If the length of requirements files list does not match the length of the constraints files list, then an exception will be raised. Therefore, if you have multiple requirements files and only one uses a constraints file, it is better to use instantiate two instances of Pip class rather than one. One instance can be used for the requirements and constraints file pairing while the other can be used for the rest of the requirements files. Example usage #!/usr/bin/env python3 \"\"\"Example usage of Pip package metaclass.\"\"\" from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Pip from cleantest.provider import lxd config = Configure () start_hook = StartEnvHook ( name = \"install_tabulate\" , packages = [ Pip ( packages = [ \"tabulate\" ]), ], ) config . register_hook ( start_hook ) @lxd ( image = \"jammy-amd64\" , preserve = False ) def install_tabulate (): import sys try : from tabulate import tabulate print ( \"tabulate is installed.\" , file = sys . stdout ) except ImportError : print ( \"Failed to import tabulate package.\" , file = sys . stderr ) sys . exit ( 1 ) sys . exit ( 0 ) class TestLocalLXD : def test_local_lxd ( self ) -> None : results = install_tabulate () for name , result in results . items (): assert result . exit_code == 0","title":"Pip"},{"location":"user-guide/packages/pip/#working-with-pip-packages","text":"Pip is the package installer for the Python programming language. You can use it to install packages from the Python Package Index (PYPI) .","title":"Working with pip packages"},{"location":"user-guide/packages/pip/#pip-class","text":"Pip is a package metaclass that represents the Python package installation command pip install . Its constructor accepts three arguments: packages (List[str]) : List of packages to install. Packages are pulled from PYPI. Defaults to None . requirements (List[str]) : List of paths to requirements.txt files. Defaults to None . constraints (List[str]) : List of paths to constraints.txt files. Defaults to None . Warning about using multiple requirements and constraints files The requirements and constraints fields in Pip are one-to-one . If you define multiple requirements files to use and want to use a constraints file with one of the requirements files, then you will need to define a constraints file for each of the requirements files in the list. If the length of requirements files list does not match the length of the constraints files list, then an exception will be raised. Therefore, if you have multiple requirements files and only one uses a constraints file, it is better to use instantiate two instances of Pip class rather than one. One instance can be used for the requirements and constraints file pairing while the other can be used for the rest of the requirements files.","title":"Pip class"},{"location":"user-guide/packages/pip/#example-usage","text":"#!/usr/bin/env python3 \"\"\"Example usage of Pip package metaclass.\"\"\" from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Pip from cleantest.provider import lxd config = Configure () start_hook = StartEnvHook ( name = \"install_tabulate\" , packages = [ Pip ( packages = [ \"tabulate\" ]), ], ) config . register_hook ( start_hook ) @lxd ( image = \"jammy-amd64\" , preserve = False ) def install_tabulate (): import sys try : from tabulate import tabulate print ( \"tabulate is installed.\" , file = sys . stdout ) except ImportError : print ( \"Failed to import tabulate package.\" , file = sys . stderr ) sys . exit ( 1 ) sys . exit ( 0 ) class TestLocalLXD : def test_local_lxd ( self ) -> None : results = install_tabulate () for name , result in results . items (): assert result . exit_code == 0","title":"Example usage"},{"location":"user-guide/packages/snaps/","text":"Working with snap packages Snap packages are a bundle of an app and its dependencies that work across a variety of Linux distributions without modification. They are automatically managed and maintained by the snapd service running as a daemon in the background. Snaps can be run on servers, desktops, or internet-of-things devices; they greatly reduce the time-to-market of deploying applications to devices running Linux. Note Comprehensive documentation on how to write and/or develop snap packages are beyond the scope of this documentation. If you are interested in learning more about snap packages, please refer to their official documentation here: https://snapcraft.io/docs Confinement class Confinement is an enum that represents the three possible confinement modes for a snap: strict , classic , and devmode . Snaps are commonly run in strict confinement, but certain snaps are granted classic confinement which gives the snap unfettered access to the underlying host system. devmode is used when developing snaps to determine which interfaces need to be defined and connected. The class takes no arguments, but it has the following attributes: STRICT : Represents strict confinement. CLASSIC : Represents classic confinement. DEVMODE : Represents devmode confinement. Plug class Plug is a metaclass that represents a snap plug. Plugs are used to connect a snap package to another snap package. Its constructor accepts two arguments: snap (str) : Name of the snap that provides the plug. Defaults to None . name (str) : Name of the plug. Defaults to None . Slot class Slot is a metaclass that represents a snap slot. Slots are to accept connections from other snap packages. Its constructor accepts two arguments: snap (str) : Name of the snap that provides the slot. name (str) : Name of the slot. Connection class Connection is a metaclass that represents the snap connect command. It is used to connect plugs to slots after the snap packages have been installed. Its constructor accepts three arguments: plug (Plug) : Plug to connect. slot (Slot) : Slot to connect to. Defaults to None . wait (bool) : Wait for snap connect operation to complete before proceeding. Defaults to True . Connection provides one private method: _lint : Lint inputs passed to the constructor to ensure that snap connect will be a valid operation. Connection provides one public method: connect : Execute snap connect operation. Even though this method is public, it should not be used when configuring your hooks. Alias class Alias is a metaclass that represents the snap alias command. It is used to create aliases after a snap package has been installed. Its constructor accepts four arguments: snap_name (str) : Name of the snap that provides the app. app_name (str) : Name of the app to create an alias for. alias_name (str) : Name of alias to create. wait (bool) : Wait for snap alias operation to complete before proceeding. Defaults to True . Alias provides one private method: _lint : Lint inputs passed to the constructor to ensure that snap alias will be a valid operation. Alias provides one public method: alias : Execute snap alias operation. Even though this method is public, it should not be used when configuring your hooks. Snap class Snap is a package metaclass that represents the snap installation command snap install . Its constructor accepts eight arguments: snaps (List[str]) : List of snaps to install inside the test environment instance. These snaps are pulled from the public Snap Store . Defaults to None . local_snaps (List[str]) : List of file paths to local snap packages to be installed inside the test environment instance. Defaults to None . confinement (Confinement) : Confinement level to install snaps with. Defaults to Confinement.STRICT . channel (str) : Channel to install snap from. Only valid for snaps being pulled from store. Defaults to None . cohort (str) : Key of cohort that snap belongs to/should be installed with. Defaults to None . dangerous (bool) : Install unsigned snaps. Only valid for local snaps. Defaults to False . connections (List[Connection]) : List of connections to set up after snaps have been installed. Defaults to None . aliases (List[Alias]) : List of aliases to create after snaps have been installed. Defaults to None . The Snap class will attempt to install snapd inside the test environment instance if the service is not detected when the class goes to install the listed snap packages. Example usage #!/usr/bin/env python3 \"\"\"Example usage of Snap package metaclass with related classes.\"\"\" import os from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Connection , Plug , Slot , Snap from cleantest.provider import lxd root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"test_snaps\" , packages = [ Snap ( snaps = \"pypi-server\" , connections = [ Connection ( Plug ( \"pypi-server\" , \"removable-media\" ), Slot ( name = \"removable-media\" )) ], ), Snap ( local_snaps = os . path . join ( root , \"hello-world-gtk_0.1_amd64.snap\" ), dangerous = True ), ], ) config . register_hook ( start_hook ) @lxd ( image = \"jammy-amd64\" , preserve = False ) def functional_snaps (): import sys from shutil import which if which ( \"pypi-server\" ) is None : sys . exit ( 1 ) elif which ( \"hello-world-gtk\" ) is None : sys . exit ( 1 ) else : sys . exit ( 0 ) class TestLocalLXD : def test_snap_package ( self ) -> None : results = functional_snaps () for name , result in results . items (): assert result . exit_code == 0","title":"Snaps"},{"location":"user-guide/packages/snaps/#working-with-snap-packages","text":"Snap packages are a bundle of an app and its dependencies that work across a variety of Linux distributions without modification. They are automatically managed and maintained by the snapd service running as a daemon in the background. Snaps can be run on servers, desktops, or internet-of-things devices; they greatly reduce the time-to-market of deploying applications to devices running Linux. Note Comprehensive documentation on how to write and/or develop snap packages are beyond the scope of this documentation. If you are interested in learning more about snap packages, please refer to their official documentation here: https://snapcraft.io/docs","title":"Working with snap packages"},{"location":"user-guide/packages/snaps/#confinement-class","text":"Confinement is an enum that represents the three possible confinement modes for a snap: strict , classic , and devmode . Snaps are commonly run in strict confinement, but certain snaps are granted classic confinement which gives the snap unfettered access to the underlying host system. devmode is used when developing snaps to determine which interfaces need to be defined and connected. The class takes no arguments, but it has the following attributes: STRICT : Represents strict confinement. CLASSIC : Represents classic confinement. DEVMODE : Represents devmode confinement.","title":"Confinement class"},{"location":"user-guide/packages/snaps/#plug-class","text":"Plug is a metaclass that represents a snap plug. Plugs are used to connect a snap package to another snap package. Its constructor accepts two arguments: snap (str) : Name of the snap that provides the plug. Defaults to None . name (str) : Name of the plug. Defaults to None .","title":"Plug class"},{"location":"user-guide/packages/snaps/#slot-class","text":"Slot is a metaclass that represents a snap slot. Slots are to accept connections from other snap packages. Its constructor accepts two arguments: snap (str) : Name of the snap that provides the slot. name (str) : Name of the slot.","title":"Slot class"},{"location":"user-guide/packages/snaps/#connection-class","text":"Connection is a metaclass that represents the snap connect command. It is used to connect plugs to slots after the snap packages have been installed. Its constructor accepts three arguments: plug (Plug) : Plug to connect. slot (Slot) : Slot to connect to. Defaults to None . wait (bool) : Wait for snap connect operation to complete before proceeding. Defaults to True . Connection provides one private method: _lint : Lint inputs passed to the constructor to ensure that snap connect will be a valid operation. Connection provides one public method: connect : Execute snap connect operation. Even though this method is public, it should not be used when configuring your hooks.","title":"Connection class"},{"location":"user-guide/packages/snaps/#alias-class","text":"Alias is a metaclass that represents the snap alias command. It is used to create aliases after a snap package has been installed. Its constructor accepts four arguments: snap_name (str) : Name of the snap that provides the app. app_name (str) : Name of the app to create an alias for. alias_name (str) : Name of alias to create. wait (bool) : Wait for snap alias operation to complete before proceeding. Defaults to True . Alias provides one private method: _lint : Lint inputs passed to the constructor to ensure that snap alias will be a valid operation. Alias provides one public method: alias : Execute snap alias operation. Even though this method is public, it should not be used when configuring your hooks.","title":"Alias class"},{"location":"user-guide/packages/snaps/#snap-class","text":"Snap is a package metaclass that represents the snap installation command snap install . Its constructor accepts eight arguments: snaps (List[str]) : List of snaps to install inside the test environment instance. These snaps are pulled from the public Snap Store . Defaults to None . local_snaps (List[str]) : List of file paths to local snap packages to be installed inside the test environment instance. Defaults to None . confinement (Confinement) : Confinement level to install snaps with. Defaults to Confinement.STRICT . channel (str) : Channel to install snap from. Only valid for snaps being pulled from store. Defaults to None . cohort (str) : Key of cohort that snap belongs to/should be installed with. Defaults to None . dangerous (bool) : Install unsigned snaps. Only valid for local snaps. Defaults to False . connections (List[Connection]) : List of connections to set up after snaps have been installed. Defaults to None . aliases (List[Alias]) : List of aliases to create after snaps have been installed. Defaults to None . The Snap class will attempt to install snapd inside the test environment instance if the service is not detected when the class goes to install the listed snap packages.","title":"Snap class"},{"location":"user-guide/packages/snaps/#example-usage","text":"#!/usr/bin/env python3 \"\"\"Example usage of Snap package metaclass with related classes.\"\"\" import os from cleantest import Configure from cleantest.hooks import StartEnvHook from cleantest.pkg import Connection , Plug , Slot , Snap from cleantest.provider import lxd root = os . path . dirname ( os . path . realpath ( __file__ )) config = Configure () start_hook = StartEnvHook ( name = \"test_snaps\" , packages = [ Snap ( snaps = \"pypi-server\" , connections = [ Connection ( Plug ( \"pypi-server\" , \"removable-media\" ), Slot ( name = \"removable-media\" )) ], ), Snap ( local_snaps = os . path . join ( root , \"hello-world-gtk_0.1_amd64.snap\" ), dangerous = True ), ], ) config . register_hook ( start_hook ) @lxd ( image = \"jammy-amd64\" , preserve = False ) def functional_snaps (): import sys from shutil import which if which ( \"pypi-server\" ) is None : sys . exit ( 1 ) elif which ( \"hello-world-gtk\" ) is None : sys . exit ( 1 ) else : sys . exit ( 0 ) class TestLocalLXD : def test_snap_package ( self ) -> None : results = functional_snaps () for name , result in results . items (): assert result . exit_code == 0","title":"Example usage"}]}