{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to cleantest's documentation!","text":"<p><code>cleantest</code> is a testing framework for developers who need clean testing environments in a hurry.</p>"},{"location":"#history","title":"History","text":"<p>The first version of <code>cleantest</code> was authored by Jason Nucciarone when he was having trouble finding a safe way to  test destructive code locally on his system. He needed to test some code that he wrote to install and manage  the Slurm Workload Manager, but he did not want to install the Debian packages directly on his system, and he did not  want to go through the environment of setting up a CI/CD pipeline on GitHub. Irked by the idea of potentially needing  to run his IDE out of a virtual machine and test his code there, he had an idea: what if there was library that could  grab the body of a test, bring up a container, run the test inside that container, and then report back the results as  if it never left the current process?</p> <p>With his idea in mind, he set out to scratch his itch, and eventually decided to name the collection of Python  decorators he created <code>cleantest</code>. Over time, and after lots of feedback from colleagues and friends, <code>cleantest</code> is  now the library you see before you.</p>"},{"location":"#what-is-cleantest","title":"What is cleantest?","text":"<p>The sales pitch for <code>cleantest</code> is a testing framework for developers who need clean testing environments in a hurry, but is more than just that. It aims to be an easy way to test code, whether you are on your laptop or an exa-scale high-performance computing cluster. It provides tools to work with popular packaging formats, utilities  for pushing or pulling artifacts, and ways to test code across multiple Linux distributions. It also enables you to  simulate high-performance computing clusters to test software deployments and installation scripts.</p> <p>If you are interested in learning more, then head on over to installation page of this  documentation!</p>"},{"location":"about/license/","title":"Apache License","text":"<p>Version 2.0, January 2004 &lt;http://www.apache.org/licenses/&gt;</p>"},{"location":"about/license/#terms-and-conditions-for-use-reproduction-and-distribution","title":"Terms and Conditions for use, reproduction, and distribution","text":""},{"location":"about/license/#1-definitions","title":"1. Definitions","text":"<p>\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.</p> <p>\u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</p> <p>\u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License.</p> <p>\u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.</p> <p>\u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.</p> <p>\u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).</p> <p>\u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.</p> <p>\u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d</p> <p>\u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.</p>"},{"location":"about/license/#2-grant-of-copyright-license","title":"2. Grant of Copyright License","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.</p>"},{"location":"about/license/#3-grant-of-patent-license","title":"3. Grant of Patent License","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.</p>"},{"location":"about/license/#4-redistribution","title":"4. Redistribution","text":"<p>You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:</p> <ul> <li>(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and</li> <li>(b) You must cause any modified files to carry prominent notices stating that You changed the files; and</li> <li>(c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and</li> <li>(d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.</li> </ul> <p>You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.</p>"},{"location":"about/license/#5-submission-of-contributions","title":"5. Submission of Contributions","text":"<p>Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.</p>"},{"location":"about/license/#6-trademarks","title":"6. Trademarks","text":"<p>This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.</p>"},{"location":"about/license/#7-disclaimer-of-warranty","title":"7. Disclaimer of Warranty","text":"<p>Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.</p>"},{"location":"about/license/#8-limitation-of-liability","title":"8. Limitation of Liability","text":"<p>In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.</p>"},{"location":"about/license/#9-accepting-warranty-or-additional-liability","title":"9. Accepting Warranty or Additional Liability","text":"<p>While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.</p> <p>END OF TERMS AND CONDITIONS</p>"},{"location":"examples/coming-soon/","title":"Coming soon","text":"<p>This page is currently under construction</p> <p>Hey there from NucciTheBoss! I am in the process of creating some examples to demonstrate some of the cool things that you can do with cleantest such as creating a continuous integration pipeline on GitHub to test packages  or building your own micro-HPC cluster to test that your simulation works. Stay tuned!</p> <p>Examples will be added in cleantest 0.5.0</p>"},{"location":"user-guide/getting-started/","title":"Getting started with cleantest","text":"<p>Now that you have the cleantest framework installed on your system, let's get you introduced to writing some basic  tests. This example assumes that you have LXD installed and configured, and cleantest is installed correctly on  your system. If not, please revisit the installation documentation.</p> <p>Also, you will need to have pytest installed on your system as well.  You can install it using the following command:</p> <pre><code>pip install pytest\n</code></pre>"},{"location":"user-guide/getting-started/#some-background","title":"Some background","text":"<p>The goal of the cleantest framework is to provide an easy way to bring up clean testing environments without a  hassle. A \"clean test\" is a test written with cleantest that can drop on top of a pre-existing testing framework  such as pytest or unittest. These \"clean tests\" can be broken down into three parts: </p> <ol> <li>Configuration statements</li> <li>A collection of Testlets</li> <li>One or more Test Suites</li> </ol> <p>Configuration statements control the state and flow of cleantest, testlets are the tests to be run in the testing environment, and the test suites define the order in which the testlets are executed.</p>"},{"location":"user-guide/getting-started/#defining-a-testlet","title":"Defining a testlet","text":"<p>A testlet is essentially an entire Python script encapsulated in a function; it contains all the imports,  definitions, and logic a program needs to run. Here is an example of a testlet below:</p> <pre><code>from cleantest.provider import lxd\n@lxd()\ndef do_something():\nimport sys\ntry:\nimport urllib\nsys.exit(0)\nexcept ImportError:\nsys.exit(1)\n</code></pre> <p>An important thing to note about testlets is that they are not run in the same Python interpreter as the test suite.  The testlets are actually picked up by the interpreter and run somewhere else, and a <code>Result</code> object is returned  containing an exit code, stdout, and stderr. Therefore, you should always import the Python modules and assets you  need within the body of the testlet, not in the main test files.</p>"},{"location":"user-guide/getting-started/#writing-a-test-suite","title":"Writing a test suite","text":"<p>To evaluate the results of a testlet, you need a test suite. This part should be invoked by your testing framework  of choice. In our case, we used pytest:</p> <pre><code>class TestSuite:\ndef test_do_something(self) -&gt; None:\nfor name, result in do_something():\nassert result.exit_code == 0\n</code></pre> <p>The test suite should be focused solely on launching testlets and evaluating the results. You should never define  testlets inside a test suite. They should always be a top-level, globally accessible function.</p>"},{"location":"user-guide/getting-started/#bringing-it-all-together","title":"Bringing it all together","text":"<p>To bring it all together, combine the testlet and test suite combined into a single Python file:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"A basic test.\"\"\"\nfrom cleantest.provider import lxd\n@lxd(preserve=False)\ndef do_something():\nimport sys\ntry:\nimport urllib\nsys.exit(0)\nexcept ImportError:\nsys.exit(1)\nclass TestSuite:\ndef test_do_something(self) -&gt; None:\nfor name, result in do_something():\nassert result.exit_code == 0\n</code></pre> <p>Now use pytest to run the test:</p> <pre><code>pytest my_cleantest.py\n</code></pre> <p>You should see the following output from your test:</p> <pre><code>=========== test session starts ===========\nplatform linux -- Python 3.10.4, pytest-7.1.3, pluggy-1.0.0\nrootdir: /mnt/d/scratch\ncollected 1 item                                                                                                                                                                                                  \n\nbasic_test.py .                                                                                                                                                                                             [100%]\n\n=========== 1 passed in 8.95s ===========\n</code></pre> <p>Congrats, you have written your first clean test!</p>"},{"location":"user-guide/getting-started/#next-steps","title":"Next steps","text":"<p>Now that you have taken your first introductory steps with cleantest, you should now go through the rest of the documentation and examples to learn about all the things that you can do with cleantest! Of course, learning through trial and error also works.</p>"},{"location":"user-guide/hooks/","title":"Using hooks","text":"<p>Hooks are used to run actions at various stages of the cleantest lifecycle. They can be used to configure test environments after they have been created, upload dependencies into the test environment, or download artifacts after the test has finished. Currently, there are two supported hook types. Their usage is described below.</p>"},{"location":"user-guide/hooks/#startenvhook","title":"StartEnvHook","text":"<p><code>StartEnvHook</code>, or start environment hook, is a hook that is run after a test environment instance has been  created and initialized. It has two main usages:</p> <ol> <li>Install dependencies needed by the testlet.</li> <li>Uploading artifacts needed by the testlet to run.</li> </ol> <p>Start environment hooks accept the following arguments:</p> <ul> <li><code>name (str)</code>: Name of the hook. Must be unique.</li> <li><code>packages (List[Injectable])</code>: List of packages to install inside the test environment instance before running the     testlet.</li> <li><code>upload (List[Injectable])</code>: List of artifacts to upload from the local system to the test environment instance.</li> </ul>"},{"location":"user-guide/hooks/#example-usage","title":"Example usage","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Example usage of StartEnvHook.\"\"\"\nimport os\nimport pathlib\nfrom cleantest.control import Configure\nfrom cleantest.control.hooks import StartEnvHook\nfrom cleantest.data.pkg import Connection, Plug, Slot, Snap\nfrom cleantest.provider import lxd\n@lxd(image=\"ubuntu-jammy-amd64\", preserve=False)\ndef functional_snaps():\nimport sys\nfrom shutil import which\nif which(\"pypi-server\") is None:\nsys.exit(1)\nelif which(\"marktext\") is None:\nsys.exit(1)\nelse:\nsys.exit(0)\ndef test_snap_package(clean_slate) -&gt; None:\nroot = pathlib.Path(os.path.dirname(os.path.realpath(__file__)))\nconfig = Configure(\"lxd\")\nstart_hook = StartEnvHook(\nname=\"test_snaps\",\npackages=[\nSnap(\nsnaps=\"pypi-server\",\nconnections=[\nConnection(\nPlug(\"pypi-server\", \"removable-media\"),\nSlot(name=\"removable-media\"),\n)\n],\n),\nSnap(\nlocal_snaps=root / \"marktext.snap\",\ndangerous=True,\n),\n],\n)\nconfig.register_hook(start_hook)\nfor name, result in functional_snaps():\nassert result.exit_code == 0\n</code></pre>"},{"location":"user-guide/hooks/#stopenvhook","title":"StopEnvHook","text":"<p><code>StopEnvHook</code>, or stop environment hook, is a hook that is run after the testlet has completed  inside the test environment instance. It has one main usage:</p> <ol> <li>Downloading artifacts after the testlet has completed.</li> </ol> <p>Stop environment hooks accept the following arguments:</p> <ul> <li><code>name (str)</code>: Name of the hook. Must be unique.</li> <li><code>download (List[Injectable])</code>: List of artifacts to download from the test environment instance to the local system.</li> </ul>"},{"location":"user-guide/hooks/#example-usage_1","title":"Example usage","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Example usage of StopEnvHook.\"\"\"\nimport os\nimport pathlib\nimport shutil\nfrom cleantest.control import Configure\nfrom cleantest.control.hooks import StopEnvHook\nfrom cleantest.data import Dir, File\nfrom cleantest.provider import lxd\n@lxd(image=\"jammy-amd64\", preserve=True)\ndef work_on_artifacts():\nimport os\nimport pathlib\npathlib.Path(\"/root/dump.txt\").write_text(\"Dumped like a sack of rocks\")\nos.mkdir(\"/root/dump\")\npathlib.Path(\"/root/dump/dump_1.txt\").write_text(\"Oh I have been dumped again!\")\ndef test_download() -&gt; None:\nroot = pathlib.Path(os.path.dirname(os.path.realpath(__file__)))\nconfig = Configure(\"lxd\")\nstop_hook = StopEnvHook(\nname=\"download_artifact\",\ndownload=[\nFile(\"/root/dump.txt\", root / \"dump.txt\", overwrite=True,),\nDir(\"/root/dump\", root / \"dump\", overwrite=True,),\n],\n)\nconfig.register_hook(stop_hook)\nfor name, result in work_on_artifacts():\nassert (root / \"dump.txt\").is_file() is True\nassert (root / \"dump\").is_dir() is True\n(root / \"dump.txt\").unlink(missing_ok=True)\nshutil.rmtree(root / \"dump\")\n</code></pre>"},{"location":"user-guide/installation/","title":"Installation","text":""},{"location":"user-guide/installation/#install-cleantest","title":"Install cleantest","text":"<p>The latest stable release of <code>cleantest</code> can be installed using pip:</p> <pre><code>pip install cleantest\n</code></pre> <p>You can also install the latest, bleeding-edge, and potentially unstable development branch from GitHub using the following commands:</p> <pre><code>git clone https://github.com/NucciTheBoss/cleantest.git\ncd cleantest\npython3 -m pip install .\n</code></pre> Warning <p>Before you can start writing tests using cleantest, you must also set up a test environment provider.</p>"},{"location":"user-guide/installation/#setting-up-testing-environment-providers","title":"Setting up testing environment providers","text":"<p>You can use the following instructions to set up a supported test environment provider of your choice to be used with  <code>cleantest</code>. Note that you do not need to install every testing environment provider listed below; you only  need to install the providers you wish to use for testing.</p> About supported test environment providers <p>LXD is currently the only supported test environment provider. For the best experience, I encourage you to use LXD on Ubuntu. You can connect to the LXD server from other machines such as Mac, Windows, and Linux* using the LXC client.  How to set up the LXC client on Mac and Windows is beyond the scope of this documentation for now. I only currently have the means to use Ubuntu (and it is my favorite distro; sorry Arch/Fedora.) </p> <p>I have plans to add more test environment provides (ssh, libvirt/kvm, vagrant, etc.) in the future, but for now I am focused on LXD.</p>"},{"location":"user-guide/installation/#lxd","title":"LXD","text":"<p>To use LXD as a test environment provider with <code>cleantest</code>, you will need to have the snap package manager and snapd service installed on your host system. Once you have  snapd and the snap package manager on your host system, use the following command to install LXD:</p> <pre><code>sudo snap install lxd\n</code></pre> <p>After LXD has finished installing on the host system, use the following command to initialize a basic LXD cluster:</p> <pre><code>lxd init --auto\n</code></pre> <p>Once the LXD cluster finishes initializing, you can now use LXD as a test environment provider with <code>cleantest</code>.</p>"},{"location":"user-guide/parallelization/","title":"Running tests in parallel","text":"<p>cleantest has the ability to run test environment instances in parallel to increase the efficiency of test runs. You can define the number of threads to use when running test environment instances in parallel as either arguments to  the test environment provider, or you can pass the number of threads to use when the test run is started using  the <code>CLEANTEST_NUM_THREADS</code> environment variable:</p> <pre><code>CLEANTEST_NUM_THREADS=$(nproc) pytest cleantest_test_suite.py\n</code></pre> <p>This is the flow that cleantest follows when parallel testing is enabled for a testlet. Rather than proceeding through each image sequentially to bring up a test environment instance and inject the testlet, each instance is brought up independently in a separate thread and the testlet is injected there. cleantest blocks until all threads have  completed. </p> <pre><code>stateDiagram-v2\n    start : @testenvprovider(name=\"test\", image=[\"jammy-amd64\", \"focal-amd64\", \"bionic-amd64\"])\n    instances : [\"test-jammy-amd64\", \"test-focal-amd64\", \"test-bionic-amd64\"]\n    jammy : test-jammy-amd64\n    focal : test-focal-amd64\n    bionic : test-bionic-amd64\n\n    [*] --&gt; start: Test run is started\n    start --&gt; instances: cleantest identifies instances to be created\n    instances --&gt; jammy: Thread #1\n    instances --&gt; focal: Thread #2\n    instances --&gt; bionic: Thread #3\n    jammy --&gt; Results: Result of testlet\n    focal --&gt; Results: Result of testlet\n    bionic --&gt; Results: Result of testlet\n    Results --&gt; Evaluation: Result from each instance is evaluated on local system\n    Evaluation --&gt; [*]</code></pre> <p>cleantest's built-in parallel testing support is best suited for spread testing; you have a testlet that you need to test across different types of test environment instances. For testing multiple testlets in parallel, you need to use one of Python's many parallel computing libraries, or third-party tool such as xargs or GNU parallel.</p>"},{"location":"user-guide/parallelization/#examples","title":"Examples","text":""},{"location":"user-guide/parallelization/#lxd","title":"LXD","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Parallel testing example using LXD as test environment provider.\"\"\"\nfrom cleantest.control import Configure\nfrom cleantest.control.hooks import StartEnvHook\nfrom cleantest.data.pkg import Pip\nfrom cleantest.provider import lxd\n@lxd(\nimage=[\"ubuntu-jammy-amd64\", \"ubuntu-focal-amd64\", \"ubuntu-bionic-amd64\"],\npreserve=False,\nparallel=True,\nnum_threads=3,\n)\ndef install_tabulate():\nimport sys\ntry:\nfrom tabulate import tabulate\nprint(\"tabulate is installed.\", file=sys.stdout)\nexcept ImportError:\nprint(\"Failed to import tabulate package.\", file=sys.stderr)\nsys.exit(1)\nsys.exit(0)\ndef test_parallel_lxd(clean_slate) -&gt; None:\nconfig = Configure(\"lxd\")\nstart_hook = StartEnvHook(name=\"pip_injection\", packages=[Pip(packages=\"tabulate\")])\nconfig.register_hook(start_hook)\nfor name, result in install_tabulate():\ntry:\nassert result.exit_code == 0\nexcept AssertionError:\nraise Exception(f\"{name} failed. Result: {result}\")\n</code></pre>"},{"location":"user-guide/test-env-providers/","title":"Test environment providers","text":"<p>Test environment providers are the backbone of cleantest; they provide the containers or virtual machines that cleantest injects the testlets into. Test environment providers can be thought of as hypervisors that can be controlled from Python. To control test environment providers, cleantest uses Python decorators. These decorators accept arguments from the user and capture the body of the testlet.</p> <p>The following is a list of all the supported test environment providers in cleantest and how to control them.</p>"},{"location":"user-guide/test-env-providers/#lxd","title":"LXD","text":"<p>The <code>lxd</code> decorator handles running testlets inside of containers and/or virtual machines controlled by the LXD hypervisor. The decorator accepts the following arguments:</p> <ul> <li><code>name (str)</code>: Name for test environment (Default: \"test\").</li> <li><code>image (List[str])</code>: LXD image to use for test environment (Default: [\"ubuntu-jammy-amd64\"]).</li> <li><code>preserve (bool)</code>: Preserve test environment after test has completed (Default: True).</li> <li><code>parallel (bool)</code>: Run test environment instances in parallel (Default: False).</li> <li><code>num_threads (int)</code>: Number of threads to use when running test environment instances in parallel (Default: None).</li> </ul>"},{"location":"user-guide/test-env-providers/#example-usage","title":"Example usage","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Example usage of LXD test environment provider.\"\"\"\nimport os\nimport pathlib\nfrom cleantest.control import Configure\nfrom cleantest.control.hooks import StartEnvHook\nfrom cleantest.data.pkg import Charmlib, Pip\nfrom cleantest.provider import lxd\n@lxd(image=\"ubuntu-jammy-amd64\", preserve=False)\ndef install_snapd():\nimport sys\nimport charms.operator_libs_linux.v0.apt as apt\ntry:\napt.update()\napt.add_package(\"snapd\")\nprint(\"snapd installed.\", file=sys.stdout)\nexcept apt.PackageNotFoundError:\nprint(\"Package could not be found in cache or system.\", file=sys.stderr)\nsys.exit(1)\nexcept apt.PackageError as e:\nprint(f\"Could not install package. Reason: {e}\", file=sys.stderr)\nsys.exit(1)\ntry:\nsnapd = apt.DebianPackage.from_installed_package(\"snapd\")\nprint(f\"snapd version {snapd.fullversion} is installed.\", file=sys.stdout)\nexcept apt.PackageNotFoundError:\nprint(\"Snapd failed to install.\", file=sys.stderr)\nsys.exit(1)\ntry:\nfrom tabulate import tabulate\nprint(\"tabulate is installed.\", file=sys.stdout)\nexcept ImportError:\nprint(\"Failed to import tabulate package.\", file=sys.stderr)\nsys.exit(1)\nsys.exit(0)\ndef test_local_lxd(clean_slate) -&gt; None:\nroot = pathlib.Path(os.path.dirname(os.path.realpath(__file__)))\nconfig = Configure(\"lxd\")\nstart_hook = StartEnvHook(\nname=\"setup_deps\",\npackages=[\nCharmlib(\nauth_token_path=root / \"charmhub.secret\",\ncharmlibs=[\"charms.operator_libs_linux.v0.apt\"],\n),\nPip(requirements=[root / \"requirements.txt\"]),\n],\n)\nconfig.register_hook(start_hook)\nfor name, result in install_snapd():\nassert result.exit_code == 0\n</code></pre>"},{"location":"user-guide/using-diff-linux-distro/","title":"Using different Linux distributions","text":"<p>This page is currently under construction</p> <p>Hey there from NucciTheBoss! cleantest is not yet able to support multiple Linux distributions like Debian, CentOS Stream, Alma Linux, Fedora, etc. The only distro officially supported right now is Ubuntu, mostly because Ubuntu is my distro of choice, and well... I work at Canonical. You can to pull your own images with the LXD test environment provider, but I have not gotten around to making that example yet. </p> <p>Mostly what needs to be done to support multiple distros is to refactor the <code>LXDDataStore</code> class. Currently I have the defaults hardcoded in, but I would like to potentially make cleantest more intelligent. Rather than hardcode, I would like to enable querying of the <code>images:</code> endpoint and other endpoints. That information can then be loaded in at runtime so that users will always have an update-to-date image list. Please bear with me while I work  to make cleantest even better!</p> <p>Multidistro support will be added in cleantest 0.4.0</p>"},{"location":"user-guide/artifacts/directory/","title":"Working with directories","text":"<p>Directories can be uploaded to and downloaded from test environment instances as artifacts.</p>"},{"location":"user-guide/artifacts/directory/#dir-class","title":"Dir class","text":"<p>The <code>Dir</code> class represents a directory. Its constructor accepts three arguments:</p> <ul> <li><code>src (str)</code>: File path to load directory from.</li> <li><code>dest (str)</code>: File path for where to dump directory.</li> <li><code>overwrite (bool)</code>: Overwrite the directory if it already exists at dest. Defaults to False.</li> </ul> <code>Dir</code> versus <code>File</code> <p>When the <code>Dir</code> class's load method is invoked, an exception will be raised if src is determined to be a file and not a directory. This exception is raised because cleantest handles directories differently than files when dumping out to dest. If you are working with files, not directories, you should use the <code>File</code> class instead.</p>"},{"location":"user-guide/artifacts/directory/#supported-hooks","title":"Supported hooks","text":"<p>The <code>Dir</code> class's behavior changes depending on the hook it is used with. Here is a list of hooks that support <code>Dir</code> and how <code>Dir</code> behaves when accessed by them:</p> <code>StartEnvHook</code> <p>src is loaded from local system and dest is the location to dump the directory inside the test environment instance.</p> <code>StopEnvHook</code> <p>src is loaded from the test environment instance and dest is the location to dump the directory on the local system.</p>"},{"location":"user-guide/artifacts/directory/#example-usage","title":"Example usage","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Example usage of Dir class.\"\"\"\nimport os\nimport pathlib\nimport shutil\nfrom cleantest.control import Configure\nfrom cleantest.control.hooks import StartEnvHook, StopEnvHook\nfrom cleantest.data import Dir\nfrom cleantest.provider import lxd\n@lxd(image=\"ubuntu-jammy-amd64\", preserve=False)\ndef work_on_artifacts():\nimport os\nimport pathlib\nimport sys\nprint(pathlib.Path(\"/root/greetings\").is_dir(), file=sys.stdout)\nos.mkdir(\"/root/dump\")\npathlib.Path(\"/root/dump/dump_1.txt\").write_text(\"Oh I have been dumped again!\")\ndef test_upload_download(clean_slate) -&gt; None:\nroot = pathlib.Path(os.path.dirname(os.path.realpath(__file__)))\nconfig = Configure(\"lxd\")\nstart_hook = StartEnvHook(\nname=\"upload_artifact\",\nupload=[\nDir(root / \"greetings\", \"/root/greetings\"),\n],\n)\nstop_hook = StopEnvHook(\nname=\"download_artifact\",\ndownload=[\nDir(\"/root/dump\", root / \"dump\", overwrite=True,),\n],\n)\nconfig.register_hook(start_hook, stop_hook)\nfor name, result in work_on_artifacts():\nassert (root / \"dump\").is_dir() is True\nshutil.rmtree(root / \"dump\")\n</code></pre>"},{"location":"user-guide/artifacts/file/","title":"Working with files","text":"<p>Files can be uploaded to and downloaded from test environment instances as artifacts.</p>"},{"location":"user-guide/artifacts/file/#file-class","title":"File class","text":"<p>The <code>File</code> class represents a file. Its constructor accepts three arguments:</p> <ul> <li><code>src (str)</code>: File path to load file from.</li> <li><code>dest (str)</code>: File path for where to dump file.</li> <li><code>overwrite (bool)</code>: Overwrite the file if it already exists at <code>dest</code>. Defaults to False.</li> </ul> <code>File</code> versus <code>Dir</code> <p>When the <code>File</code> class's load method is invoked, an exception will be raised if src is determined to be a directory  and not a file. This exception is raised because cleantest handles files differently than directories when  dumping out to dest. If you are working with directories, not files, you should use the <code>Dir</code>  class instead.</p>"},{"location":"user-guide/artifacts/file/#supported-hooks","title":"Supported hooks","text":"<p>The <code>File</code> class's behavior changes depending on the hook it is used with. Here is a list of hooks that support <code>File</code> and how <code>File</code> behaves when accessed by them:</p> <code>StartEnvHook</code> <p>src is loaded from local system and dest is the location to dump the file inside the test environment instance.</p> <code>StopEnvHook</code> <p>src is loaded from the test environment instance and dest is the location to dump the file on the local system.</p>"},{"location":"user-guide/artifacts/file/#example-usage","title":"Example usage","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Example usage of File class.\"\"\"\nimport os\nimport pathlib\nfrom cleantest.control import Configure\nfrom cleantest.control.hooks import StartEnvHook, StopEnvHook\nfrom cleantest.data import File\nfrom cleantest.provider import lxd\n@lxd(image=\"ubuntu-jammy-amd64\", preserve=False)\ndef work_on_artifacts():\nimport pathlib\nimport sys\nprint(pathlib.Path(\"/root/greeting.txt\").is_file(), file=sys.stdout)\npathlib.Path(\"/root/dump.txt\").write_text(\"Dumped like a sack of rocks\")\ndef test_upload_download(clean_slate) -&gt; None:\nroot = pathlib.Path(os.path.dirname(os.path.realpath(__file__)))\nconfig = Configure(\"lxd\")\nstart_hook = StartEnvHook(\nname=\"upload_artifact\",\nupload=[\nFile(root / \"greeting.txt\", \"/root/greeting.txt\"),\n],\n)\nstop_hook = StopEnvHook(\nname=\"download_artifact\",\ndownload=[\nFile(\"/root/dump.txt\", root / \"dump.txt\", overwrite=True,),\n],\n)\nconfig.register_hook(start_hook, stop_hook)\nfor name, result in work_on_artifacts():\nassert (root / \"dump.txt\").is_file() is True\n(root / \"dump.txt\").unlink(missing_ok=True)\n</code></pre>"},{"location":"user-guide/packages/charmlib/","title":"Working with charm libraries","text":"<p>Charm libraries are special Python modules used in charmed operators deployed by Juju. They are an easy way to distribute reusable code without needing to involve any particular package build system. Fundamentally, charm libraries are used to provide a means for charm developers to make the implementation of any  relation they define as simple as possible for other charm developers.</p> Note <p>Comphrensive documentation on how to write/develop/use charm libraries are beyond the scope of this documentation. If you are interested in learning more about charm libraries, please refer to their official documentation here: https://juju.is/docs/sdk/libraries</p>"},{"location":"user-guide/packages/charmlib/#charmlib-class","title":"Charmlib class","text":"<p><code>Charmlib</code> is a package metaclass that represents the charm library installation command charmcraft fetch-lib. Its constructor accepts two arguments:</p> <ol> <li><code>auth_token_path (str)</code>: File path to a Charmhub authentication token. This token is needed to download charm     libraries from charmhub.io.</li> <li><code>charmlibs (List[str])</code>: List of charm libraries to install inside the test environment instance.</li> </ol> <p>Charm libraries are not installed a special directory such as site-packages or dist-packages; they are directly installed to a lib/ directory under your current working directory. Therefore, the <code>Charmlib</code> class modifies the PYTHONPATH environment variable to inform the Python interpreter that there are importable modules under lib/.</p>"},{"location":"user-guide/packages/charmlib/#example-usage","title":"Example usage","text":"<p>First, you need to create a Charmhub authentication token. This can be accomplished by using the following command in your shell:</p> <pre><code>charmcraft login --export charmhub.secret\n</code></pre> <p>After authenticating with Charmhub (you may need to create an Ubuntu One account), you can now use the example test script below:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"Example usage of Charmlib package metaclass.\"\"\"\nimport os\nimport pathlib\nfrom cleantest.control import Configure\nfrom cleantest.control.hooks import StartEnvHook\nfrom cleantest.data.pkg import Charmlib\nfrom cleantest.provider import lxd\n@lxd(image=\"ubuntu-jammy-amd64\", preserve=False)\ndef install_snapd():\nimport sys\nimport charms.operator_libs_linux.v0.apt as apt\ntry:\napt.update()\napt.add_package(\"snapd\")\nprint(\"snapd installed.\", file=sys.stdout)\nexcept apt.PackageNotFoundError:\nprint(\"Package could not be found in cache or system.\", file=sys.stderr)\nsys.exit(1)\nexcept apt.PackageError as e:\nprint(f\"Could not install package. Reason: {e}\", file=sys.stderr)\nsys.exit(1)\ntry:\nsnapd = apt.DebianPackage.from_installed_package(\"snapd\")\nprint(f\"snapd version {snapd.fullversion} is installed.\", file=sys.stdout)\nexcept apt.PackageNotFoundError:\nprint(\"Snapd failed to install.\", file=sys.stderr)\nsys.exit(1)\nsys.exit(0)\ndef test_local_lxd(clean_slate) -&gt; None:\nroot = pathlib.Path(os.path.dirname(os.path.realpath(__file__)))\nconfig = Configure(\"lxd\")\nstart_hook = StartEnvHook(\nname=\"setup_deps\",\npackages=[\nCharmlib(\nauth_token_path=root / \"charmhub.secret\",\ncharmlibs=[\"charms.operator_libs_linux.v0.apt\"],\n),\n],\n)\nconfig.register_hook(start_hook)\nfor name, result in install_snapd():\nassert result.exit_code == 0\n</code></pre>"},{"location":"user-guide/packages/pip/","title":"Working with pip packages","text":"<p>Pip is the package installer for the Python programming language. You can use it to install packages from the Python Package Index (PYPI).</p>"},{"location":"user-guide/packages/pip/#pip-class","title":"Pip class","text":"<p><code>Pip</code> is a package metaclass that represents the Python package installation command pip install. Its constructor accepts three arguments:</p> <ul> <li><code>packages (List[str])</code>: List of packages to install. Packages are pulled from PYPI. Defaults to None.</li> <li><code>requirements (List[str])</code>: List of paths to requirements.txt files. Defaults to None.</li> <li><code>constraints (List[str])</code>: List of paths to constraints.txt files. Defaults to None.</li> </ul> Warning about using multiple requirements and constraints files <p>The requirements and constraints fields in <code>Pip</code> are one-to-one. If you define multiple requirements files to use and want to use a constraints file with one of the requirements files, then you will need to define a constraints file for each of the requirements files in the list. If the length of requirements files list does not match the length of the constraints files list, then an exception will be raised.</p> <p>Therefore, if you have multiple requirements files and only one uses a constraints file, it is better to use instantiate two instances of <code>Pip</code> class rather than one. One instance can be used for the requirements and  constraints file pairing while the other can be used for the rest of the requirements files.</p>"},{"location":"user-guide/packages/pip/#example-usage","title":"Example usage","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Example usage of Pip package metaclass.\"\"\"\nimport os\nimport pathlib\nfrom cleantest.control import Configure\nfrom cleantest.control.hooks import StartEnvHook\nfrom cleantest.data.pkg import Pip\nfrom cleantest.provider import lxd\n@lxd(image=\"ubuntu-jammy-amd64\", preserve=False)\ndef install_snapd():\nimport sys\ntry:\nfrom tabulate import tabulate\nprint(\"tabulate is installed.\", file=sys.stdout)\nexcept ImportError:\nprint(\"Failed to import tabulate package.\", file=sys.stderr)\nsys.exit(1)\nsys.exit(0)\ndef test_local_lxd(clean_slate) -&gt; None:\nroot = pathlib.Path(os.path.dirname(os.path.realpath(__file__)))\nconfig = Configure(\"lxd\")\nstart_hook = StartEnvHook(\nname=\"setup_deps\",\npackages=[\nPip(requirements=[root / \"requirements.txt\"]),\n],\n)\nconfig.register_hook(start_hook)\nfor name, result in install_snapd():\nassert result.exit_code == 0\n</code></pre>"},{"location":"user-guide/packages/snaps/","title":"Working with snap packages","text":"<p>Snap packages are a bundle of an app and its dependencies that work across a variety of Linux distributions without modification. They are automatically managed and maintained by the snapd  service running as a daemon in the background. Snaps can be run on servers, desktops, or internet-of-things devices;  they greatly reduce the time-to-market of deploying applications to devices running Linux.</p> Note <p>Comprehensive documentation on how to write and/or develop snap packages are beyond the scope of this documentation. If you are interested in learning more about snap packages, please refer to their official documentation here: https://snapcraft.io/docs</p>"},{"location":"user-guide/packages/snaps/#confinement-class","title":"Confinement class","text":"<p><code>Confinement</code> is an enum that represents the three possible confinement modes for a snap: strict, classic,  and devmode. Snaps are commonly run in strict confinement, but certain snaps are granted classic confinement which gives the snap unfettered access to the underlying host system. devmode is used when developing snaps to determine which interfaces need to be defined and connected.</p> <p>The class takes no arguments, but it has the following attributes:</p> <ul> <li><code>STRICT</code>: Represents strict confinement.</li> <li><code>CLASSIC</code>: Represents classic confinement.</li> <li><code>DEVMODE</code>: Represents devmode confinement.</li> </ul>"},{"location":"user-guide/packages/snaps/#plug-class","title":"Plug class","text":"<p><code>Plug</code> is a metaclass that represents a snap plug. Plugs are used to connect a snap package to another snap package. Its constructor accepts two arguments:</p> <ul> <li><code>snap (str)</code>: Name of the snap that provides the plug. Defaults to None.</li> <li><code>name (str)</code>: Name of the plug. Defaults to None.</li> </ul>"},{"location":"user-guide/packages/snaps/#slot-class","title":"Slot class","text":"<p><code>Slot</code> is a metaclass that represents a snap slot. Slots are to accept connections from other snap packages. Its constructor accepts two arguments:</p> <ul> <li><code>snap (str)</code>: Name of the snap that provides the slot.</li> <li><code>name (str)</code>: Name of the slot.</li> </ul>"},{"location":"user-guide/packages/snaps/#connection-class","title":"Connection class","text":"<p><code>Connection</code> is a metaclass that represents the snap connect command. It is used to connect plugs to slots after the snap packages have been installed. Its constructor accepts three arguments:</p> <ul> <li><code>plug (Plug)</code>: Plug to connect.</li> <li><code>slot (Slot)</code>: Slot to connect to. Defaults to None.</li> <li><code>wait (bool)</code>: Wait for snap connect operation to complete before proceeding. Defaults to True.</li> </ul> <p><code>Connection</code> provides one private method:</p> <ul> <li><code>_lint</code>: Lint inputs passed to the constructor to ensure that snap connect will be a valid operation.</li> </ul> <p><code>Connection</code> provides one public method:</p> <ul> <li><code>connect</code>: Execute snap connect operation. Even though this method is public, it should not be used when      configuring your hooks.</li> </ul>"},{"location":"user-guide/packages/snaps/#alias-class","title":"Alias class","text":"<p><code>Alias</code> is a metaclass that represents the snap alias command. It is used to create aliases after a snap package has been installed. Its constructor accepts four arguments:</p> <ul> <li><code>snap_name (str)</code>: Name of the snap that provides the app.</li> <li><code>app_name (str)</code>: Name of the app to create an alias for.</li> <li><code>alias_name (str)</code>: Name of alias to create.</li> <li><code>wait (bool)</code>: Wait for snap alias operation to complete before proceeding. Defaults to True.</li> </ul> <p><code>Alias</code> provides one private method:</p> <ul> <li><code>_lint</code>: Lint inputs passed to the constructor to ensure that snap alias will be a valid operation.</li> </ul> <p><code>Alias</code> provides one public method:</p> <ul> <li><code>alias</code>: Execute snap alias operation. Even though this method is public, it should not be used when     configuring your hooks.</li> </ul>"},{"location":"user-guide/packages/snaps/#snap-class","title":"Snap class","text":"<p><code>Snap</code> is a package metaclass that represents the snap installation command <code>snap install</code>. Its constructor accepts eight arguments:</p> <ul> <li><code>snaps (List[str])</code>: List of snaps to install inside the test environment instance. These snaps are pulled from     the public Snap Store. Defaults to None.</li> <li><code>local_snaps (List[str])</code>: List of file paths to local snap packages to be installed inside the test environment     instance. Defaults to None.</li> <li><code>confinement (Confinement)</code>: Confinement level to install snaps with. Defaults to Confinement.STRICT.</li> <li><code>channel (str)</code>: Channel to install snap from. Only valid for snaps being pulled from store. Defaults to None.</li> <li><code>cohort (str)</code>: Key of cohort that snap belongs to/should be installed with. Defaults to None.</li> <li><code>dangerous (bool)</code>: Install unsigned snaps. Only valid for local snaps. Defaults to False.</li> <li><code>connections (List[Connection])</code>: List of connections to set up after snaps have been installed. Defaults to None.</li> <li><code>aliases (List[Alias])</code>: List of aliases to create after snaps have been installed. Defaults to None.</li> </ul> <p>The <code>Snap</code> class will attempt to install snapd inside the test environment instance if the service is not detected when the class goes to install the listed snap packages.</p>"},{"location":"user-guide/packages/snaps/#example-usage","title":"Example usage","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Example usage of Snap package metaclass with related classes.\"\"\"\nimport os\nimport pathlib\nfrom cleantest.control import Configure\nfrom cleantest.control.hooks import StartEnvHook\nfrom cleantest.data.pkg import Connection, Plug, Slot, Snap\nfrom cleantest.provider import lxd\n@lxd(image=\"ubuntu-jammy-amd64\", preserve=False)\ndef functional_snaps():\nimport sys\nfrom shutil import which\nif which(\"pypi-server\") is None:\nsys.exit(1)\nelif which(\"marktext\") is None:\nsys.exit(1)\nelse:\nsys.exit(0)\ndef test_snap_package(clean_slate) -&gt; None:\nroot = pathlib.Path(os.path.dirname(os.path.realpath(__file__)))\nconfig = Configure(\"lxd\")\nstart_hook = StartEnvHook(\nname=\"test_snaps\",\npackages=[\nSnap(\nsnaps=\"pypi-server\",\nconnections=[\nConnection(\nPlug(\"pypi-server\", \"removable-media\"),\nSlot(name=\"removable-media\"),\n)\n],\n),\nSnap(\nlocal_snaps=[root / \"marktext.snap\"],\ndangerous=True,\n),\n],\n)\nconfig.register_hook(start_hook)\nfor name, result in functional_snaps():\nassert result.exit_code == 0\n</code></pre>"}]}